;David Gulyas
;1302870
;CMPUT 325
;LAB H01
:Assignment 1

;QUESTION 1
;This function forms a list of pairs from the elements in a
;given list, in the way that the first two elements form the
;first pair, in the reversed order, and the next two form the
;second pair in the reversed order, and so on. If the given
;list is even, it will get a list of proper pairs; if it
;contains an odd number of elements, the last element is
;paired with itself.
;The function first tests if the list L is null. If it is it
;returns null since there is nothing left to process. It then
;tests if there is only one element left in the list. If there
;is then that element is paired with itself and stuck into
;another list. This is then returned.
;If there are two or more elements in the list then
;they are extracted and used to form a pair. This pair is then
;inserted into whatever is returned by the recursive call to
;the function using L minus the first two elements.
;(form-pair '(a1 b 2 c 3)) ==> ((1 a) (2 b) (3 c))
;(form-pair '(a1 b 2 c 3 d)) ==> ((1 a) (2 b) (3 c) (d d))
(defun form-pair (L)
    (if (null L)
        nil
        (if (null (cdr L))
            (cons (cons (car L) L) nil )
            (cons (cons (car (cdr L)) (cons (car L) nil))
            (form-pair (cdr (cdr L))))
        )
    )
)

;QUESTION 2
;(defun drop-pair L)
;This function takes L which is a list of pairs, each of which
;consists of two arithmetic expressions; the function returns
;the list with all expressions evaluated; in addition, if the
;two expressions in a pair evaluate to the same value, the pair
; will be dropped from the resulting list.
;It first tests for an empty list then returns nil if so. It then
;tests to see if the elements in the next pair evaluate to the same
;thing. If they do it returns nil else is evaluates each element and
;makes a new list of the values switched around. This is then cons'ed
;onto the front of the recursive call.
;eg (drop-pair (((* 2 3) (- 5 4)) ((+ 1 9) 7) ((* 3 4) 12))) -> ((1 6) (7 10))
(defun drop-pair (L)
    (if (null L)
        nil
        (if(eq (evalu (car (cdr (car L)))) (evalu(car (car L))))
            nil
            (cons (list (evalu (car (cdr (car L))))(evalu(car (car L)))) (drop-pair (cdr L)))
            )
    )
)


;This function replaces the eval function since it wasn't on the
;list of allowed functions.
;It first tests to see if L is atomic. If it is then we assume
;is is a number and return it. It then used apply to calculate
;the result. Right now it doesn't test to see if
;there are two elements or if those elements are numbers.
(defun evalu (L)
    (if (atom L)
        L
        (apply (car L) (cdr L))
    )
)

;QUESTION 3
;(remove-duplicate L)

;It takes x as a list of atoms and removes repeated ones in x.
;The order of the elements in the resulting list should preserve
;the order in the given list.
;eg (remove-duplicate '(a b c a d b)) ==> (a b c d) or (c a d b)
;Note that in both the order in the given list is preserved.
;This is acomplished by going through the lists of tokens and testing
;if each tokn appears in the list ahead of it. If if does then it is
;discarded from the new list. If it doesn't then it is cons'ed onto the
;rest of the new list. test-duplicate tests is x in in the
;list L.
(defun remove-duplicate (L)
    (if (null L)
        nil
        (if (null (test-duplicate (car L)(cdr L)))
            (remove-duplicate (cdr L))
            (cons (test-duplicate (car L)(cdr L)) (remove-duplicate (cdr L)))
        )
    )
)

(defun test-duplicate (x L)
    (if (null L)
        x
        (if (eq x (car L))
            nil
            (test-duplicate x (cdr L))
        )
    )
)

"
;QUESTION 4
;(my-count L)
;
;Counts the distinct atoms in a non nested list.
;(my-count '(a b a c d c)) ==> 4
It does this by testing if the first character in L appears in
the rest of the list. If it doesn't it returns the number of
elements in the cdr of L. If it does It adds one to that value.
A better explanation is: if (car L) is in (cdr L) then we can
simply drop (car L) in our counting.
"
(defun my-count (L)
    (if (null L)
        0
        (if (null (test-duplicate (car L)(cdr L)))
            (my-count (cdr L))
            (+ 1 (my-count (cdr L)))
        )
    )
)

"
Question 5
Returns the power set of L.
"
(defun power-set (L)
    (if (null L)
        nil
        (cons nil (real-power-set L))
    )
)
(defun real-power-set (L)
(if (null L)
        nil
        (if (null (cdr L))
            (cons L nil)
             (append (insert (cons (car L) nil) (real-power-set (cdr L))) (real-power-set (cdr L)))
        )
    )
)
;inserts x ar the front of all the elements in L including the null element
(defun insert (x L)
    (if (null L)
        (cons x nil)
        (cons (append x (car L)) (insert x (cdr L)))
    )
)




"
QUESTION 6a
"
(defun findOne (Name Type L)
    (if (eq Type 'worst)
        (cdr (findWorst Name nil L))
        (cdr (findBest Name nil L))
    )
)

(defun findWorst (Name worstSoFar L)
    (if (null L)
		worstSoFar
		(if  (eq (car (car L)) name) 
            (if (null worstSoFar)
                (findWorst name (car L) (cdr L))
                (if (< (toNumber (car (cdr (cdr (car L))))) (toNumber (car (cdr (cdr worstSoFar)))))
                    (findWorst name (car L) (cdr L))
                    (findWorst name worstSoFar (cdr L))
                )
            )
            (findWorst name worstSoFar (cdr L))
        )
    )
)

(defun findBest (Name bestSoFar L)
	(if (null L)
		bestSoFar
		(if  (eq (car (car L)) name) 
            (if (null bestSoFar)
                (findBest name (car L) (cdr L))
                (if (> (toNumber (car (cdr (cdr (car L))))) (toNumber (car (cdr (cdr bestSoFar)))))
                    (findBest name (car L) (cdr L))
                    (findBest name bestSoFar (cdr L))
                )
            )
            (findBest name bestSoFar (cdr L))
        )
    )
)


(defun toNumber (x)
    (if (null x)
        nil
        (cond
            ((eq x 'F) 1)
            ((eq x 'D) 2)
            ((eq x 'D+) 3)
            ((eq x 'C-) 4)
            ((eq x 'C) 5)
            ((eq x 'C+) 6)
            ((eq x 'B-) 7)
            ((eq x 'B) 8)
            ((eq x 'B+) 9)
            ((eq x 'A-) 10)
            ((eq x 'A) 11)
            ((eq x 'A+) 12)
            (T nil)
        )
    )
)

"
QUESTION 6b
"
"
findAll only sorts the returned list from filterGrades. Ths was done because sorting
only needs to be done once at the end.
"
(defun findAll (name L)
    (if (null L)
        null
        (sortGrades(filterGrades name L))
        )
    )
)

"
Contains the recursive part of the question. The the cdr part of the first triple 
of L will be cons'ed onto the rest of the list if the name in the first triple 
of L matches the name argument. This leaves us with a list of course grade pairs
that belong to the name argument. 
"
(defun filterGrades (name L)
    (if (null L)
        nil
        (if (eq name (car(car L)))
            (cons (cdr(car L)) (filterGrades name (cdr L)))
            (filterGrades name (cdr L))
        )
    )
)

"
sort function for class grade pair. L is of the form
((cmputxxx grade)(cmputxxx grade)...)
"
(defun sortGrades (L)
    (sort L 'compareGrade)
)

"
tells the sort function how to compare two class grade pairs
L1 and L2 are class grade pairs of the form
(cmputxxx grade)
where grade is a valid letter grade
Returns true if the course number of L1 is less then the course number of L2
"
(defun compareGrade (L1 L2)
    (string-lessp (car L1) (car L2))
)

"
Question 7
"
(defun reached (x L)
    (if (null L)
        x
        ()



)





